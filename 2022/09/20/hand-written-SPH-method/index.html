

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.ico">
  <link rel="icon" href="/img/favicon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#84674f">
  <meta name="author" content="Ryan LI, Wen Wang">
  <meta name="keywords" content="">
  
    <meta name="description" content="under construction...                         After inspecting the CUDA Particles simulation template. A simplest SPH model is implemented based on it.">
<meta property="og:type" content="article">
<meta property="og:title" content="hand written SPH method">
<meta property="og:url" content="https://daydreamatnight.github.io/2022/09/20/hand-written-SPH-method/index.html">
<meta property="og:site_name" content="ShouRou">
<meta property="og:description" content="under construction...                         After inspecting the CUDA Particles simulation template. A simplest SPH model is implemented based on it.">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://daydreamatnight.github.io/index/CUDA_SPH.png">
<meta property="article:published_time" content="2022-09-20T06:23:37.000Z">
<meta property="article:modified_time" content="2022-12-11T17:42:03.588Z">
<meta property="article:author" content="Ryan LI">
<meta property="article:tag" content="fluid dynamics">
<meta property="article:tag" content="CUDA">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://daydreamatnight.github.io/index/CUDA_SPH.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>hand written SPH method - ShouRou</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- ä¸»é¢˜ä¾èµ–çš„å›¾æ ‡åº“ï¼Œä¸è¦è‡ªè¡Œä¿®æ”¹ -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"daydreamatnight.github.io","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":1,"cursorChar":"","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":"Â§"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":4},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":true,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 40vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>ShouRou</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/marble1.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.6)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="hand written SPH method"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        Ryan LI, Wen Wang
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-09-20 14:23" pubdate>
          September 20, 2022 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          <!-- compatible with older versions-->
          21k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          <!-- compatible with older versions-->
          71 minutes
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">hand written SPH method</h1>
            
            
              <div class="markdown-body">
                
                <div class="note note-danger">
            <p>under construction...</p>
          </div>
<div class="note note-primary">
            <p>After inspecting the CUDA Particles simulation template. A simplest SPH model is implemented based on it.</p>
          </div>
<span id="more"></span>
<h2 id="introduction">Introduction</h2>
<h3 id="related-works">Related works</h3>
<p>The first open-source SPH library ever is <a target="_blank" rel="noopener" href="https://wiki.manchester.ac.uk/sphysics/index.php/Main_Page">SPHysics FORTRAN code</a>. It is developed by researchers at the Johns Hopkins University (US), the University of Vigo (Spain), the University of Manchester (UK), and the University of Rome, La Sapienza.</p>
<p>The earliest CUDA-based SPH is <a target="_blank" rel="noopener" href="http://www.gpusph.org/about/">GPUSPH</a>, (GitHub <a target="_blank" rel="noopener" href="https://github.com/GPUSPH/gpusph">gpusph</a>)<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="HÃ©rault, A., Bilotta, G., &amp; Dalrymple, R. A. (2010). Sph on gpu with cuda. *Journal of Hydraulic Research*, *48*(sup1), 74-79.">[1]</span></a></sup>. It is based on the CUDA Particles simulation template<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="Green, S. (2008). CUDA Particles. Technical Report contained in the CUDA SDK, www.nvidia.com.">[2]</span></a></sup>, the same code reviewed in the last blog. And the newest release is version 5.0.</p>
<p>Besides, <a target="_blank" rel="noopener" href="https://dual.sphysics.org/">DualSPHysics</a>, (GitHub <a target="_blank" rel="noopener" href="https://github.com/DualSPHysics/DualSPHysics">DualSPHysics</a>)<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="Crespo, A. J., DomÃ­nguez, J. M., Rogers, B. D., GÃ³mez-Gesteira, M., Longshaw, S., Canelas, R. J. F. B., ... &amp; GarcÃ­a-Feal, O. (2015). DualSPHysics: Open-source parallel CFD solver based on Smoothed Particle Hydrodynamics (SPH). *Computer Physics Communications*, *187*, 204-216.">[3]</span></a></sup>, a directly inherited variation from the SPHysics. Provides similar implementations with several optimization strategies. It is called "dual" because it supports both CPU and GPU implementations of the core functions.</p>
<p>Resources: <a target="_blank" rel="noopener" href="https://interactivecomputergraphics.github.io/SPH-Tutorial/">SPH-Tutorial</a><sup id="fnref:21" class="footnote-ref"><a href="#fn:21" rel="footnote"><span class="hint--top hint--rounded" aria-label="Koschier, D., Bender, J., Solenthaler, B., &amp; Teschner, M. (2020). Smoothed particle hydrodynamics techniques for the physics based simulation of fluids and solids. *arXiv preprint arXiv:2009.06944*.">[21]</span></a></sup> by <a target="_blank" rel="noopener" href="https://github.com/InteractiveComputerGraphics/SPlisHSPlasH">SPlisHSPlasH</a>, <a target="_blank" rel="noopener" href="https://github.com/Zhijie-YU/Learning_Notes/blob/master/Notes_SPH.md">SPH Learning Notes</a></p>
<h3 id="simplifications">Simplifications</h3>
<p>Compared with the matured developed SPH code, see DualSPHysics User Guide<sup id="fnref:13" class="footnote-ref"><a href="#fn:13" rel="footnote"><span class="hint--top hint--rounded" aria-label="Crespo, A. J. C., Dominguez, J. M., GÃ³mez-Gesteira, M., Barreiro, A., &amp; Rogers, B. (2011). User guide for DualSPHysics code. *University of Vigo: Vigo, Spain*.">[13]</span></a></sup>, lots of simplifications are made in order to implement a simplest version of SPH code.</p>
<h4 id="verlet-scheme">Verlet Scheme</h4>
<p>There are two methods for numerical integration schemes, Verlet<sup id="fnref:6" class="footnote-ref"><a href="#fn:6" rel="footnote"><span class="hint--top hint--rounded" aria-label="Verlet L. 1967. Computer experiments on classical fluids. I. Thermodynamical properties of  Lennard-Jones molecules. Physical Review, 159, 98-103.">[6]</span></a></sup> and mainstream Symplectic<sup id="fnref:7" class="footnote-ref"><a href="#fn:7" rel="footnote"><span class="hint--top hint--rounded" aria-label="Leimkuhler BJ, Reich S, Skeel RD. 1996. Integration Methods for Molecular dynamic IMA  Volume in Mathematics and its application. Springer.">[7]</span></a></sup> applied in DualSPHysics. The first is computationally simple with low stability. The second is a two-step prediction-correction method with higher stability. I choose the 1st order Euler backward and Verlet for simplification.</p>
<h4 id="kernel-function">Kernel function</h4>
<p>The performance of an SPH model depends heavily on the choice of the smoothing kernel. Instead of the Cubic Spline kernel <sup id="fnref:9" class="footnote-ref"><a href="#fn:9" rel="footnote"><span class="hint--top hint--rounded" aria-label="Monaghan JJ and Lattanzio JC. 1985. A refined method for astrophysical problems. Astron.  Astrophys, 149, 135â€“143.">[9]</span></a></sup> and Quintic Wendland kernel<sup id="fnref:10" class="footnote-ref"><a href="#fn:10" rel="footnote"><span class="hint--top hint--rounded" aria-label="Molteni, D and Colagrossi A. 2009. A simple procedure to improve the pressure evaluation in  hydrodynamic context using the SPH, Computer Physics Communications, 180 (6), 861â€“872">[10]</span></a></sup>, the Poly6, Spicky and Viscosity kernel functions are applied followed work of MÃ¼ller et. al<sup id="fnref:15" class="footnote-ref"><a href="#fn:15" rel="footnote"><span class="hint--top hint--rounded" aria-label="MÃ¼ller, M., Charypar, D., &amp; Gross, M. (2003, July). Particle-based fluid simulation for interactive applications. In *Proceedings of the 2003 ACM SIGGRAPH/Eurographics symposium on Computer animation* (pp. 154-159)">[15]</span></a></sup>.</p>
<h4 id="formulations-list">Formulations List</h4>
<p>These are the formulation list:</p>
<ul>
<li>Neighbor list
<ul class="task-list">
<li><input type="checkbox" disabled checked>
DomÃ­nguez<sup id="fnref:19" class="footnote-ref"><a href="#fn:19" rel="footnote"><span class="hint--top hint--rounded" aria-label="DomÃ­nguez, J. M., Crespo, A. J. C., GÃ³mezâ€Gesteira, M., &amp; Marongiu, J. (2011). Neighbour lists in smoothed particle hydrodynamics. *International Journal for Numerical Methods in Fluids*, *67*(12), 2026-2042.">[19]</span></a></sup></li>
</ul></li>
<li>Time integration scheme:
<ul class="task-list">
<li><input type="checkbox" disabled checked>
Euler backward</li>
<li><input type="checkbox" disabled checked>
Verlet<sup id="fnref:6" class="footnote-ref"><a href="#fn:6" rel="footnote"><span class="hint--top hint--rounded" aria-label="Verlet L. 1967. Computer experiments on classical fluids. I. Thermodynamical properties of  Lennard-Jones molecules. Physical Review, 159, 98-103.">[6]</span></a></sup></li>
<li><input type="checkbox" disabled>
Symplectic<sup id="fnref:7" class="footnote-ref"><a href="#fn:7" rel="footnote"><span class="hint--top hint--rounded" aria-label="Leimkuhler BJ, Reich S, Skeel RD. 1996. Integration Methods for Molecular dynamic IMA  Volume in Mathematics and its application. Springer.">[7]</span></a></sup></li>
</ul></li>
<li><input type="checkbox" disabled>
Variable time step</li>
<li><strong>Kernel</strong> functions:
<ul class="task-list">
<li><input type="checkbox" disabled>
Cubic Spline kernel <sup id="fnref:9" class="footnote-ref"><a href="#fn:9" rel="footnote"><span class="hint--top hint--rounded" aria-label="Monaghan JJ and Lattanzio JC. 1985. A refined method for astrophysical problems. Astron.  Astrophys, 149, 135â€“143.">[9]</span></a></sup></li>
<li><input type="checkbox" disabled>
Quintic Wendland kernel <sup id="fnref:11" class="footnote-ref"><a href="#fn:11" rel="footnote"><span class="hint--top hint--rounded" aria-label="Wendland H. 1995. Piecewiese polynomial, positive definite and compactly supported radial  functions of minimal degree. Advances in Computational Mathematics 4, 389-396.">[11]</span></a></sup></li>
<li><input type="checkbox" disabled checked>
Poly6, Spicky and Viscosity kernel<sup id="fnref:15" class="footnote-ref"><a href="#fn:15" rel="footnote"><span class="hint--top hint--rounded" aria-label="MÃ¼ller, M., Charypar, D., &amp; Gross, M. (2003, July). Particle-based fluid simulation for interactive applications. In *Proceedings of the 2003 ACM SIGGRAPH/Eurographics symposium on Computer animation* (pp. 154-159)">[15]</span></a></sup></li>
</ul></li>
<li>Pressure formulation (WCSPH)
<ul class="task-list">
<li><input type="checkbox" disabled checked>
Ideal gas equation<sup id="fnref:16" class="footnote-ref"><a href="#fn:16" rel="footnote"><span class="hint--top hint--rounded" aria-label="Desbrun, M., Gascuel, MP. (1996). Smoothed Particles: A new paradigm for animating highly deformable bodies. In: Boulic, R., HÃ©gron, G. (eds) Computer Animation and Simulation â€™96. Eurographics. Springer, Vienna. https://doi.org/10.1007/978-3-7091-7486-9_5">[16]</span></a></sup></li>
<li><input type="checkbox" disabled>
Monaghan/Tait equation<sup id="fnref:12" class="footnote-ref"><a href="#fn:12" rel="footnote"><span class="hint--top hint--rounded" aria-label="Monaghan JJ. 1994. Simulating free surface flows with SPH. Journal of Computational Physics,  110, 399â€“406.">[12]</span></a></sup></li>
<li><input type="checkbox" disabled>
Pressure Poisson equation<sup id="fnref:17" class="footnote-ref"><a href="#fn:17" rel="footnote"><span class="hint--top hint--rounded" aria-label="Koschier D, Bender J, Solenthaler B, et al. Smoothed Particle Hydrodynamics Techniques for the Physics Based Simulation of Fluids and Solids[J]. 2019.">[17]</span></a></sup></li>
</ul></li>
<li>Viscosity formulation:
<ul class="task-list">
<li><input type="checkbox" disabled>
Artificial viscosity <sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="Monaghan JJ. 1992. Smoothed particle hydrodynamics. Annual Review of Astronomy and  Astrophysics, 30, 543- 574.">[4]</span></a></sup></li>
<li><input type="checkbox" disabled checked>
Laminar viscosity<sup id="fnref:22" class="footnote-ref"><a href="#fn:22" rel="footnote"><span class="hint--top hint--rounded" aria-label="Lo EYM and Shao S. 2002. Simulation of near-shore solitary wave mechanics by an  incompressible SPH method. Applied Ocean Research, 24, 275-286.">[22]</span></a></sup></li>
<li><input type="checkbox" disabled>
Laminar viscosity<sup id="fnref:22" class="footnote-ref"><a href="#fn:22" rel="footnote"><span class="hint--top hint--rounded" aria-label="Lo EYM and Shao S. 2002. Simulation of near-shore solitary wave mechanics by an  incompressible SPH method. Applied Ocean Research, 24, 275-286.">[22]</span></a></sup> + SPS turbulence model<sup id="fnref:23" class="footnote-ref"><a href="#fn:23" rel="footnote"><span class="hint--top hint--rounded" aria-label="Gotoh H, Shao S, Memita T. 2001. SPH-LES model for numerical investigation of wave  interaction with partially immersed breakwater. Coastal Engineering Journal, 46(1), 39â€“63.">[23]</span></a></sup><sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="Dalrymple RA and Rogers BD. 2006. Numerical modeling of water waves with the SPH method. Coastal Engineering, 53, 141â€“147.">[5]</span></a></sup></li>
</ul></li>
<li>Density treatment:
<ul class="task-list">
<li><input type="checkbox" disabled>
Delta-SPH formulation <sup id="fnref:10" class="footnote-ref"><a href="#fn:10" rel="footnote"><span class="hint--top hint--rounded" aria-label="Molteni, D and Colagrossi A. 2009. A simple procedure to improve the pressure evaluation in  hydrodynamic context using the SPH, Computer Physics Communications, 180 (6), 861â€“872">[10]</span></a></sup></li>
</ul></li>
<li>Boundary condition
<ul class="task-list">
<li><input type="checkbox" disabled checked>
Dynamic particles<sup id="fnref:18" class="footnote-ref"><a href="#fn:18" rel="footnote"><span class="hint--top hint--rounded" aria-label="Crespo AJC, GÃ³mez-Gesteira M and Dalrymple RA. 2007. Boundary conditions generated by  dynamic particles in SPH methods. Computers, Materials &amp; Continua, 5, 173-184">[18]</span></a></sup></li>
<li><input type="checkbox" disabled>
Virtual particles<sup id="fnref:12" class="footnote-ref"><a href="#fn:12" rel="footnote"><span class="hint--top hint--rounded" aria-label="Monaghan JJ. 1994. Simulating free surface flows with SPH. Journal of Computational Physics,  110, 399â€“406.">[12]</span></a></sup></li>
<li><input type="checkbox" disabled>
Mirroring particles<sup id="fnref:20" class="footnote-ref"><a href="#fn:20" rel="footnote"><span class="hint--top hint--rounded" aria-label="Libersky, L. D., Petschek, A. G., Carney, T. C., Hipp, J. R., &amp; Allahdadi, F. A. (1993). High strain Lagrangian hydrodynamics: a three-dimensional SPH code for dynamic material response. *Journal of computational physics*, *109*(1), 67-75.">[20]</span></a></sup></li>
</ul></li>
</ul>
<h2 id="update-step-by-step">Update Step by Step</h2>
<p>The fundamental algorithm is very similar to the CUDA demo<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="Green, S. (2008). CUDA Particles. Technical Report contained in the CUDA SDK, www.nvidia.com.">[2]</span></a></sup>, only needs several changes for the control functions.</p>
<h3 id="stage-1-neighboring-searching">Stage 1: Neighboring searching</h3>
<h4 id="theorem-influence-area">Theorem: Influence area</h4>
<p><img src="/2022/09/20/hand-written-SPH-method/Influence length illustration of SPH.PNG" srcset="/img/loading.gif" lazyload alt="Influence length illustration of SPH. The circles denoted by ð‘–,ð‘— represent target particles, interacting particles. In addition, qr is the influence radius of target particle. " style="zoom:25%;"></p>
<p>The influence area illustration of SPH is shown above. The circles denoted by <span class="math inline">\(i\)</span>, <span class="math inline">\(j\)</span> represent the target particle and the interacting particles, respectively. The target particle only interacts with particles within the circle (dashed) with a radius of <span class="math inline">\(dist_{critic} = 2h\)</span>. With <span class="math inline">\(q = {dist}/{h}\)</span> denoting the non-dimensional distance between two particles. <span class="math inline">\(q_{critc} = 2\)</span> is the non-dimensional influence radius of the target particle.</p>
<p>The original <span class="math inline">\(dist_{critc}\)</span> in the demo<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="Green, S. (2008). CUDA Particles. Technical Report contained in the CUDA SDK, www.nvidia.com.">[2]</span></a></sup> is the sum of the radius of the two interacting particles, i.e. <span class="math inline">\(dist_{critc} = 2 radius\)</span> in the case of uniform radius particles. And <span class="math inline">\(h_{critic} = radius, q_{critic} = 1\)</span>.</p>
<p>There are two ways of defining <span class="math inline">\(h\)</span>,</p>
<p>By <span class="math inline">\(coefh\)</span> (default 1): <span class="math display">\[
h = coefh \cdot \sqrt{dx^2+dy^2+dz^2} \cdot dp
\]</span></p>
<p><span class="math display">\[
h = coefh \cdot \sqrt{dx^2+dy^2+dz^2} dp
\]</span> By <span class="math inline">\(hdp\)</span> (default 1.5): <span class="math display">\[
h = hdp \cdot dp
\]</span> where characteristic length <span class="math inline">\(dp\)</span> is choice to be the original particle distance when generating them, <span class="math inline">\(dp = 2*radius\)</span> in demo<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="Green, S. (2008). CUDA Particles. Technical Report contained in the CUDA SDK, www.nvidia.com.">[2]</span></a></sup>.</p>
<div class="note note-info">
            <p>There is no concept of "particle diameter" in SPH as in the collision model<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="Green, S. (2008). CUDA Particles. Technical Report contained in the CUDA SDK, www.nvidia.com.">[2]</span></a></sup>.</p><p>In the case of particles with the same radius, for the collision model, the interaction boundary of the particles is the physical particle diameter. While in SPH, the interaction boundary is defined freely. Particles are only the discretized <strong>points</strong> in the space.</p><p>The length unit <span class="math inline">\(dp\)</span> is just a physical length easy to choose.</p><p>In the demo<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="Green, S. (2008). CUDA Particles. Technical Report contained in the CUDA SDK, www.nvidia.com.">[2]</span></a></sup>, <span class="math inline">\(dp\)</span> is equal to the diameter of particles. That means particles are generated (by function <code>reset</code>) tightly packed together, i.e. simple cubic stacking as shown below.</p><p><img src="/2022/09/20/hand-written-SPH-method/Simple cubic stacking illustration.jpg" srcset="/img/loading.gif" lazyload alt="Simple cubic stacking illustration, from https://iu.pressbooks.pub/openstaxchemistry/chapter/10-6-lattice-structures-in-crystalline-solids/" style="zoom:50%;"></p>
          </div>
<p>The second <span class="math inline">\(hdp\)</span> method is applied in the code because of its simplicity. The equivalent <span class="math inline">\(hdp = 0.5\)</span></p>
<h4 id="algorithm-neighboring-search">Algorithm: neighboring search</h4>
<p><img src="/2022/09/20/hand-written-SPH-method/Neighboringsearching illustration of SPH.PNG" srcset="/img/loading.gif" lazyload alt="Influence area illustration of SPH, The circles denoted by ð‘–,ð‘—,ð‘˜ represent target particles, true neighbor particles, and false neighbor particles. From [12]" style="zoom:20%;"></p>
<p>In order to find the true neighboring particles, instead of brute-force searching i.e. examining distances with all of the particles in the domain, a smart way is called neighboring search.</p>
<p>A grid as shown above is introduced, dividing the whole domain into cells. For each cell, a neighbor list containing all the particle ids in neighbor cells gets rebuilt periodically (every time step, or every 10-time step as in HÃ©rault's work<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="HÃ©rault, A., Bilotta, G., &amp; Dalrymple, R. A. (2010). Sph on gpu with cuda. *Journal of Hydraulic Research*, *48*(sup1), 74-79.">[1]</span></a></sup>). When processing a target particle, the distances only get examined with particles in the neighbor list of its located target cell. In this way, the examining times are reduced dramatically and the shared memory can be well leveraged to avoid massive global memory access (not implemented here)</p>
<h5 id="grid-span">Grid span</h5>
<p>At a glance, in the demo<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="Green, S. (2008). CUDA Particles. Technical Report contained in the CUDA SDK, www.nvidia.com.">[2]</span></a></sup>, the grid is generated in the way that the grid spans <span class="math inline">\(dx, dy, dz\)</span> equal <span class="math inline">\(dp\)</span> as shown below in the code block.</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">float</span> cellSize = m_params.particleRadius * <span class="hljs-number">2.0f</span>;  <span class="hljs-comment">// cell size equal to particle diameter</span>
m_params.cellSize = <span class="hljs-built_in">make_float3</span>(cellSize, cellSize, cellSize);</code></pre></div>
<p>Actually, the grid span is defined as the <strong>influencing distance <span class="math inline">\(2h\)</span></strong>, as shown below. If the span is smaller, the interaction area will not be included by the neighboring area. Yet if the span is larger, the searching will not be the most efficient.</p>
<p><img src="/2022/09/20/hand-written-SPH-method/Largest influence length in grid illustration of SPH.PNG" srcset="/img/loading.gif" lazyload alt="Largest influence length in grid illustration of SPH" style="zoom:20%;"></p>
<div class="note note-info">
            <p>Note the term "grid" represents 3 different concepts:</p><ul><li><p>equal-space structured mesh, span <span class="math inline">\(2h\)</span>, divides the computational domain, e.g.</p><p>"A grid is introduced, dividing the whole domain into cells"</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> GRID_SIZE       64</span>
uint gridDim = GRID_SIZE;
gridSize.x = gridSize.y = gridSize.z = gridDim;
<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;grid: %d x %d x %d = %d cells\n&quot;</span>, gridSize.x, gridSize.y, gridSize.z, gridSize.x*gridSize.y*gridSize.z);</code></pre></div></li><li><p>equal-space structured mesh, span <span class="math inline">\(dp\)</span>, used to generate a block of particles on its lattices, e.g.<code>ParticleSystem::reset</code></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">float</span> jitter = m_params.particleRadius*<span class="hljs-number">0.01f</span>;
uint s = (<span class="hljs-type">int</span>) <span class="hljs-built_in">ceilf</span>(<span class="hljs-built_in">floor</span>(<span class="hljs-built_in">powf</span>((<span class="hljs-type">float</span>) m_numParticles, <span class="hljs-number">1.0f</span> / <span class="hljs-number">3.0f</span>)*<span class="hljs-number">1000</span>)/<span class="hljs-number">1000</span>);
uint gridSize[<span class="hljs-number">3</span>];
gridSize[<span class="hljs-number">0</span>] = gridSize[<span class="hljs-number">1</span>] = gridSize[<span class="hljs-number">2</span>] = s;
<span class="hljs-built_in">initGrid</span>(gridSize, m_params.particleRadius*<span class="hljs-number">2.0f</span>, jitter, m_numParticles);</code></pre></div></li><li><p>The GPU grid containing blocks of <code>blockSize</code> when running on the device e.g. in the code:</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// compute grid and thread block size for a given number of elements</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">computeGridSize</span><span class="hljs-params">(uint n, uint blockSize, uint &amp;numBlocks, uint &amp;numThreads)</span></span>
<span class="hljs-function"></span>&#123;
    numThreads = <span class="hljs-built_in">min</span>(blockSize, n);
    numBlocks = <span class="hljs-built_in">iDivUp</span>(n, numThreads);
&#125;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">collide</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-comment">// thread per particle</span>
    uint numThreads, numBlocks;
    <span class="hljs-built_in">computeGridSize</span>(numParticles, <span class="hljs-number">64</span>, numBlocks, numThreads);

    <span class="hljs-comment">// execute the kernel</span>
    collideD&lt;&lt;&lt; numBlocks, numThreads &gt;&gt;&gt;();
&#125;</code></pre></div></li></ul><p><img src="/2022/09/20/hand-written-SPH-method/maximum numbe of particles in the domain.png" srcset="/img/loading.gif" lazyload alt="maximum numbe of particles in the domain" style="zoom:25%;"></p><p>In demo<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="Green, S. (2008). CUDA Particles. Technical Report contained in the CUDA SDK, www.nvidia.com.">[2]</span></a></sup>, when particle numbers are <span class="math inline">\(64\times64\times64 = 262144\)</span>, the first two grids coincide with each other. And <span class="math inline">\(262144\)</span> is the maximum particle number according to the domain. And <code>numBlocks = 4096</code>.</p>
          </div>
<div class="note note-secondary">
            <p>Wait, there is another tiny difference (It turns out that we are lucky to be able to leave it but it is important to know this).</p><p>There are two ways of Building the Grid. One simple approach is via <strong>Atomic Operations</strong>, which is well illustrated by demo<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="Green, S. (2008). CUDA Particles. Technical Report contained in the CUDA SDK, www.nvidia.com.">[2]</span></a></sup>. In this approach, we allocate two arrays to the global memory:</p><ul><li>gridCounters â€“ this stores the number of particles in each cell so far. It is initialized to zero at the start of each frame.</li><li>gridCells â€“ this stores the particle indices for each cell, and has room for a fixed maximum number of particles per cell.</li></ul><p>Why <strong>fixed</strong> maximum number of particles per cell? It is because it is inefficient (nearly impossible) for GPU to allocate memories dynamically, which means the maximum number of particles per grid cell must be pre-defined.</p><p>In the scenario of demo<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="Green, S. (2008). CUDA Particles. Technical Report contained in the CUDA SDK, www.nvidia.com.">[2]</span></a></sup>, this maximum number is easy to choose as the distance between particles is limited. Because particles in the collision model are rigid bodies and overlapping is not allowed, the maximum is set to be 4 particles per grid cell in the demo<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="Green, S. (2008). CUDA Particles. Technical Report contained in the CUDA SDK, www.nvidia.com.">[2]</span></a></sup>, taking the assumption of simple cubic stacking. But in SPH, there is no such limitation as discussed above. We must make careful assumptions about it when we use the Atomic Operations method to build the grid.</p><p>Luckily, we are using the second approach, via <strong>sorting</strong>, slightly difficult to understand, also well illustrated in the demo<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="Green, S. (2008). CUDA Particles. Technical Report contained in the CUDA SDK, www.nvidia.com.">[2]</span></a></sup>, and no need for the limitation of the maximum particles per cell.</p><p>Yet in HÃ©rault's work<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="HÃ©rault, A., Bilotta, G., &amp; Dalrymple, R. A. (2010). Sph on gpu with cuda. *Journal of Hydraulic Research*, *48*(sup1), 74-79.">[1]</span></a></sup>, the maximum lenth of the neighboring list is pre-defined, so that the examining loop is further unrolled during compilation for efficiency. We are not going to do that at the first time although is it easy to apply.</p>
          </div>
<h4 id="code">code</h4>
<h5 id="original">original</h5>
<p>The distance examination is applied in <code>__device__ float3 collideSpheres</code> as:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">__device__</span>
<span class="hljs-function">float3 <span class="hljs-title">collideSpheres</span><span class="hljs-params">(float3 posA, float3 posB,</span></span>
<span class="hljs-params"><span class="hljs-function">                      float3 velA, float3 velB,</span></span>
<span class="hljs-params"><span class="hljs-function">                      <span class="hljs-type">float</span> radiusA, <span class="hljs-type">float</span> radiusB,</span></span>
<span class="hljs-params"><span class="hljs-function">                      <span class="hljs-type">float</span> attraction)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-comment">// calculate relative position</span>
    float3 relPos = posB - posA;

    <span class="hljs-type">float</span> dist = <span class="hljs-built_in">length</span>(relPos);
    <span class="hljs-type">float</span> collideDist = radiusA + radiusB;

    float3 force = <span class="hljs-built_in">make_float3</span>(<span class="hljs-number">0.0f</span>);

    <span class="hljs-keyword">if</span> (dist &lt; collideDist)
    &#123;
        <span class="hljs-comment">// force += ...</span>
    &#125;

    <span class="hljs-keyword">return</span> force;
&#125;</code></pre></div>
<p>The radius of two particles are set to be different, not suitable for SPH model.</p>
<h5 id="update">update</h5>
<p>step 0: house keeping</p>
<ul>
<li>comment out <code>collider</code> for simplicity and any function related to it such as: <code>M_MOVE</code> mode and its controller.</li>
</ul>
<p>step 1: parameters/arguments, functions renaming, switching and introducing</p>
<ul>
<li><p>Rename the functions and params from collision related to SPH related such as:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">collideSpheres</span>() -&gt; <span class="hljs-built_in">SPHParticles</span>()
collideDist -&gt; interactDist</code></pre></div></li>
<li><p>Introduce <code>dp</code> into <code>params</code> (i.e. <code>struct SimParams</code>), change grid span for generating the particles from particle diameter to <code>dp</code>, change the domain grid span to <code>2*h</code></p></li>
<li><p>Introduce <code>hdp,h</code> into <code>params</code>, set <code>hdp=0.5</code> and <code>h=hdp*dp</code></p></li>
<li><p>Make <code>dp</code> and <code>hdp</code> modifiable by flag via <code>getCmdLineArgumentFloat</code></p></li>
</ul>
<p>step 2: In function <code>SPHParticles</code>, change the distance limitation <code>interactDist</code> to <code>2*h</code> so that distance limitation same as before.</p>
<ul>
<li><p>The original <code>__device__ float3 collideSpheres</code> is changed to be:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">__device__</span>
<span class="hljs-function">float3 <span class="hljs-title">SPHParticles</span><span class="hljs-params">(float3 posA, float3 posB,</span></span>
<span class="hljs-params"><span class="hljs-function">                      float3 velA, float3 velB,</span></span>
<span class="hljs-params"><span class="hljs-function">                      <span class="hljs-type">float</span> h, <span class="hljs-type">float</span> attraction)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-comment">// calculate relative position</span>
    float3 relPos = posB - posA;

    <span class="hljs-type">float</span> dist = <span class="hljs-built_in">length</span>(relPos);
    <span class="hljs-type">float</span> interactDist = <span class="hljs-number">2</span>*h;

    float3 force = <span class="hljs-built_in">make_float3</span>(<span class="hljs-number">0.0f</span>);

    <span class="hljs-keyword">if</span> (dist &lt; interactDist)
    &#123;
        <span class="hljs-comment">// force += ...</span>
    &#125;

    <span class="hljs-keyword">return</span> force;
&#125;</code></pre></div></li>
<li><p>minor cleanups</p>
<ul>
<li><p>The boundary condition is parameterized for different setting of <code>gridsize</code> other than 64. A new parameter <code>worldMaxPos</code> is introduced right after the <code>worldOrigin</code> parameter as:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (pos.x &gt; params.worldMaxPos.x - params.dp*<span class="hljs-number">0.5</span>)
&#123;
    pos.x = params.worldMaxPos.x - params.dp*<span class="hljs-number">0.5</span>;
    vel.x *= params.boundaryDamping;
&#125;</code></pre></div></li>
<li><p>Add more flags operations such as <code>gridLength</code></p></li>
<li><p>Another key factor introduced for dump all the parameters as:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;k&#x27;</span>:
    psystem-&gt;<span class="hljs-built_in">dumpParameters</span>();
    <span class="hljs-keyword">break</span>;</code></pre></div></li>
</ul></li>
</ul>
<h4 id="results-of-different-hdps">Results of different hdps</h4>
<table>
<thead>
<tr class="header">
<th><code>./particles hdp=0.5</code></th>
<th><code>./particles hdp=0.8</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><img src="/2022/09/20/hand-written-SPH-method/dhp_0_5_dt_0_5_o.gif" srcset="/img/loading.gif" lazyload alt="dhp=0.5 for collision model, same result with demo[2]" style="zoom:55%;"></td>
<td><img src="/2022/09/20/hand-written-SPH-method/dhp_0_8_dt_0_5_o.gif" srcset="/img/loading.gif" lazyload alt="dhp=0.8 for collision model" style="zoom:60%;"></td>
</tr>
</tbody>
</table>
<h3 id="stage-2-verlet-time-scheme">Stage 2: Verlet time scheme</h3>
<h4 id="theorem">Theorem</h4>
<p>Instead of the simple Euler backward time discretization scheme originally applied in the integration step, the Verlet scheme <sup id="fnref:6" class="footnote-ref"><a href="#fn:6" rel="footnote"><span class="hint--top hint--rounded" aria-label="Verlet L. 1967. Computer experiments on classical fluids. I. Thermodynamical properties of  Lennard-Jones molecules. Physical Review, 159, 98-103.">[6]</span></a></sup> is used such that: <span class="math display">\[
\begin{aligned}
\boldsymbol{v}_a^{n+1}&amp;=\boldsymbol{v}_a^{n-1}+2 \Delta t \boldsymbol{F}_a^n \\
\boldsymbol{r}_a^{n+1}&amp;=\boldsymbol{r}_a^n+\Delta t \boldsymbol{V}_a^n+0.5 \Delta t^2 \boldsymbol{F}_a^n
\end{aligned}
\]</span></p>
<p>For every <span class="math inline">\(N_s\)</span> time steps: <span class="math display">\[
\begin{aligned}
\boldsymbol{v}_a^{n+1}&amp;=\boldsymbol{v}_a^n+\Delta t \boldsymbol{F}_a^n \\
\boldsymbol{r}_a^{n+1}&amp;=\boldsymbol{r}_a^n+\Delta t \boldsymbol{V}_a^n+0.5 \Delta t^2 \boldsymbol{F}_a^n
\end{aligned}
\]</span></p>
<h4 id="code-1">Code</h4>
<h5 id="original-1">original</h5>
<p>The DEM is implemented in two steps, i.e. two locations:</p>
<ol type="1">
<li><code>struct integrate_functor</code> related params: <code>gravity</code>, <code>globalDamping</code>, <code>boundaryDamping</code>.</li>
<li><code>float3 SPHParticles()</code> related params: <code>spring</code>, <code>damping</code>, <code>shear</code>.</li>
</ol>
<p>The work flow in this stage is such that:</p>

<div class="markmap-container" style="height:200px">
  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;integrate_functor&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;Update velocity (vel) with gravity&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;Update velocity (vel) with globalDamping&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;Update position (pos) with velocity (vel)&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;Boundary condition&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;SPH(*vel)&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;SPHD&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;force = 0&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;force += SPHCell&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;(Neighboring search)&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;SPHParticles&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:12,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;force += spring&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:12,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;force += damping&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:12,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;force += shear&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:12,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;force += attraction&quot;}]}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;vel + force&quot;}]}]}],&quot;p&quot;:{}}"/>
</div>

<h5 id="update-1">update</h5>
<p>step 0: <strong>debug</strong>, the velocity update formula</p>
<ul>
<li><p>In original <code>SPHD</code> function, the new velocity is updated such that:</p>
<div class="code-wrapper"><pre><code class="hljs c++">newVel[originalIndex] = <span class="hljs-built_in">make_float4</span>(vel + force, <span class="hljs-number">0.0f</span>);</code></pre></div>
<p>the velocity is added with the force without a multiplying of the delta time.</p></li>
<li><p>Provide the <code>SPHD</code> with extra argument <code>deltatime</code> (changing <code>SPH</code> as well) and change the original code as:</p>
<div class="code-wrapper"><pre><code class="hljs c++">newVel[originalIndex] = <span class="hljs-built_in">make_float4</span>(vel + deltaTime*force, <span class="hljs-number">0.0f</span>);</code></pre></div></li>
</ul>
<p>step 1: Rearrange <code>integrate_functor</code> and <code>SPHD</code>. Moving <code>force</code> out as a global parameter.</p>
<ul>
<li>In <code>SPHD</code>, the gravity (original in <code>integrate_functor</code>) and the collision forces (spring, damping, shear and attraction) are added to one argument <code>force</code>.
<ul>
<li>Delete the argument <code>newVel</code> in SPHD and SPH.</li>
<li>Add the argument <code>newForce</code> and update the force with gravity, the code structure as <code>newVel</code>:</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs c++">newForce[originalIndex]= <span class="hljs-built_in">make_float4</span>(force, <span class="hljs-number">0.0f</span>);</code></pre></div></li>
<li><code>integrate_functor</code> takes the argument <code>force</code> from <code>SPHD</code> and update the <code>vel</code> and <code>pos</code> as before (1st order Euler backword scheme).
<ul>
<li>Delete the force of globalDamping.</li>
</ul></li>
</ul>
<div class="note note-warning">
            <p>Note that In the original code, force is treated as temporal parameter, no memory of force needed.</p>
          </div>
<p>step 2: rename the <code>integrate_functor</code> as <code>integrate_verlet</code> and update the <code>vel</code> and <code>pos</code> via the Verlet scheme</p>
<ul>
<li><code>integrate_verlet</code> takes the pointer of <code>step</code>, <code>vel_1</code> and <code>vel_2</code> from outside, change these augments inside, mimicking the <code>vel</code>.
<ul>
<li><code>vel_1</code> and <code>vel_2</code> indicates the velocity fields from last, and last of last step, respectively</li>
</ul></li>
</ul>
<p>step 3: <strong>debug</strong>, "nan" exists when updating the particles</p>
<ul>
<li><p>Inspect <code>force</code>, <code>vel</code> and <code>pos</code> of particles in <code>dumpparticles</code></p>
<p>found that the <code>force</code> returns "nan" because of the distance of two particles being 0.</p></li>
<li><p>Add minimum distance condition to the updating force process in <code>SPHParticles</code> as:</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (dist &lt; interactDist &amp;&amp; relPos.x &gt; <span class="hljs-number">1e-10</span> &amp;&amp; relPos.y &gt; <span class="hljs-number">1e-10</span> &amp;&amp; relPos.z &gt; <span class="hljs-number">1e-10</span> &amp;&amp; relPos.x &lt; <span class="hljs-number">-1e-10</span> &amp;&amp; relPos.y &lt; <span class="hljs-number">-1e-10</span> &amp;&amp; relPos.z &lt; <span class="hljs-number">-1e-10</span>)</code></pre></div></li>
</ul>
<p>step 4: make <code>deltaTime (0.04)</code> and <code>renderStep (10)</code> as variables, changeable without recompilation. Print those information before rendering.</p>
<h4 id="result-of-verlet-time-scheme">Result of Verlet time scheme</h4>
<table>
<thead>
<tr class="header">
<th><img src="/2022/09/20/hand-written-SPH-method/verlet_dt_0_5_o.gif" srcset="/img/loading.gif" lazyload alt="deltatime=0.5s for particle system" style="zoom:70%;"></th>
<th><img src="/2022/09/20/hand-written-SPH-method/verlet_dt_0_04_o.gif" srcset="/img/loading.gif" lazyload alt="deltatime=0.04s for particle system, render every 10 time steps" style="zoom:70%;"></th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p>The nearly second order Verlet time scheme requires a much lower <span class="math inline">\(\Delta t\)</span>, for real time simulation, one-step-render-one-step-update is not applicable.</p>
<h3 id="stage-3-control-function">Stage 3: Control function</h3>
<h4 id="theorem-sph-system">Theorem: SPH system</h4>
<p>Instead of the DEM method that has been used for collision model, the control function between particles are changed, inspired by this <a target="_blank" rel="noopener" href="https://www.notion.so/Smoothed-Particle-Hydrodynamics-Particle-Based-Fluid-Simulation-for-Interactive-Applications-9061b2ec19de49e1857ec80fa30d1e50">notebook</a> and work by Muller et. al<sup id="fnref:15" class="footnote-ref"><a href="#fn:15" rel="footnote"><span class="hint--top hint--rounded" aria-label="MÃ¼ller, M., Charypar, D., &amp; Gross, M. (2003, July). Particle-based fluid simulation for interactive applications. In *Proceedings of the 2003 ACM SIGGRAPH/Eurographics symposium on Computer animation* (pp. 154-159)">[15]</span></a></sup></p>
<h5 id="density-derived-continuity-equation">Density (Derived continuity equation):</h5>
<p><span class="math display">\[
\rho(\boldsymbol{r_i}) = \sum_j m_j W_{poly6}(\boldsymbol{r_i} - \boldsymbol{r_j},h), \quad i\ne j
\]</span> where the the mass of all particles <span class="math inline">\(m =\rho_0\frac{4}{3}\pi*\left(\frac{dp}{2}\right)^3,dp=\frac{2}{64}.\)</span> Weakly-compressible assumption is adopted, so the mass of each particle is fixed and the density varies.</p>
<h5 id="pressure-state-equation">Pressure (state equation):</h5>
<p>Based on the state of equation by Desbrun<sup id="fnref:16" class="footnote-ref"><a href="#fn:16" rel="footnote"><span class="hint--top hint--rounded" aria-label="Desbrun, M., Gascuel, MP. (1996). Smoothed Particles: A new paradigm for animating highly deformable bodies. In: Boulic, R., HÃ©gron, G. (eds) Computer Animation and Simulation â€™96. Eurographics. Springer, Vienna. https://doi.org/10.1007/978-3-7091-7486-9_5">[16]</span></a></sup> <span class="math display">\[
\begin{aligned}
&amp;P=k(\rho - \rho_0),\
\end{aligned}
\]</span></p>
<p>where the rest density <span class="math inline">\(\rho_0=1000, k=3\)</span>.</p>
<h5 id="force-momentum-equation">Force (momentum equation):</h5>
<p>Pressure force, gravity force and viscosity force is considered as: <span class="math display">\[
\begin{aligned}
\frac{d \boldsymbol{v_i}}{d t}&amp;=-\sum_j\frac{1}{\rho_i}\nabla P_{j}+\boldsymbol{g}+\boldsymbol{\Gamma} \\
&amp;= -\sum_j \left( m_j\frac{P_i+P_j}{2\rho_i\rho_j}\right)\nabla W_{spiky}(\boldsymbol{r_i} - \boldsymbol{r_j},h) + \boldsymbol{g}+\boldsymbol{\Gamma}, \quad i \ne j \\
\end{aligned}
\]</span> where the gravity force <span class="math inline">\(\boldsymbol{g} = (0, -1.0, 0) m/s^2\)</span>. <span class="math inline">\(\boldsymbol{\Gamma}\)</span> is the dissipation terms, here, we only consider the linear viscosity<sup id="fnref:22" class="footnote-ref"><a href="#fn:22" rel="footnote"><span class="hint--top hint--rounded" aria-label="Lo EYM and Shao S. 2002. Simulation of near-shore solitary wave mechanics by an  incompressible SPH method. Applied Ocean Research, 24, 275-286.">[22]</span></a></sup>, i.e. <span class="math display">\[
\begin{aligned}
\boldsymbol{\Gamma}&amp;=\mu\sum_jm_j\frac{\boldsymbol{v_j} - \boldsymbol{v_i}}{\rho_i  \rho_j}\nabla^2 W_{viscosity}(\boldsymbol{r_i} - \boldsymbol{r_j},h),\quad i\ne j
\end{aligned}
\]</span> where the viscosity of the fluid <span class="math inline">\(\mu = 5.0\)</span></p>
<h5 id="kernel-function-1">Kernel function</h5>
<p><span class="math inline">\(W(\boldsymbol{r}, h)\)</span> denotes the kernel function, we choose three different kernels. In 3D dimensions, they are defined as:</p>
<p><img src="/2022/09/20/hand-written-SPH-method/kernel function of SPH, from 14.jpg" srcset="/img/loading.gif" lazyload alt="kernel function of SPH, from 14" style="zoom:30%;"> <span class="math display">\[
\begin{aligned}
&amp;W_{poly6}(\boldsymbol{r}, h)=\frac{315}{64\pi h^9}\left(h^2-r^2\right)^3, \quad 0 \leq r \leq h \\
&amp;W_{spiky}(\boldsymbol{r}, h)=\frac{15}{\pi h^6}\left(h-r\right)^3, \quad 0 \leq r \leq h \\
&amp;\nabla W_{spiky}(\boldsymbol{r}, h)=-\frac{45}{\pi h^6}\left(h-r\right)^2\frac{\boldsymbol{r}}{r}, \quad 0 \leq r \leq h \\ 
&amp;W_{viscosity}(\boldsymbol{r}, h)=\frac{15}{2\pi h^3}\left(-\frac{r^3}{2h^3}+\frac{r^2}{h^2}+\frac{h}{2r}-1\right), \quad 0 \leq r \leq h \\
&amp;\nabla^2W_{viscosity}(\boldsymbol{r}, h)=\frac{45}{\pi h^6}\left(h-r\right), \quad 0 \leq r \leq h \\
\end{aligned}
\]</span></p>
<h4 id="code-2">Code</h4>
<h5 id="original-2">original</h5>
<p>The collision force is calculated from the particle positions, plus some constants. Refer to the work flow in <a href="#stage-2-verlet-time-scheme">stage 2</a>.</p>
<h5 id="update-2">update</h5>
<p>step 1: add more parameters</p>
<ul>
<li>define more vector parameters to <code>particleSystem</code>
<ul>
<li><code>float density</code></li>
<li><code>float pressure</code></li>
</ul></li>
<li>add more scalar parameters to <code>particleSystem.params</code>
<ul>
<li><code>mass</code>, <code>rho0</code>, <code>k</code></li>
</ul></li>
</ul>
<p>step 2: Add new file <code>particles_kernel_functions.cuh</code>to directory <code>src</code>, containing the Poly6, gradient of Spiky and Laplacian of Viscosity kernel functions</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">__device__</span>
<span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">poly6Kernel</span><span class="hljs-params">(float3 posA, float3 posB, <span class="hljs-type">float</span> h)</span>     <span class="hljs-comment">//3-D</span></span>
<span class="hljs-function"></span>&#123; 
    float3 relPos = posB - posA;
    <span class="hljs-type">float</span> dist = <span class="hljs-built_in">length</span>(relPos);
    h = <span class="hljs-number">2</span>*h;
    <span class="hljs-type">float</span> wker = <span class="hljs-number">315.0f</span> / <span class="hljs-number">64.0f</span> / PI / <span class="hljs-built_in">pow</span>(h, <span class="hljs-number">9</span>) * <span class="hljs-built_in">pow</span>(h*h-dist*dist,<span class="hljs-number">3</span>); 
    <span class="hljs-keyword">return</span> wker;
&#125;</code></pre></div>
<p>step 3: update <code>density</code> then <code>pressure</code> by function <code>SPHDensityPressure</code></p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// accumulation density with another</span>
<span class="hljs-function">__device__</span>
<span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">SPHDensityParticles</span><span class="hljs-params">(float3 posA, float3 posB,</span></span>
<span class="hljs-params"><span class="hljs-function">                      <span class="hljs-type">float</span> h, <span class="hljs-type">float</span> mass)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-comment">// calculate relative position</span>
    float3 relPos = posB - posA;

    <span class="hljs-type">float</span> dist = <span class="hljs-built_in">length</span>(relPos);
    <span class="hljs-type">float</span> interactDist = <span class="hljs-number">2</span>*h;

    <span class="hljs-type">float</span> density = <span class="hljs-number">0.0f</span>;
    <span class="hljs-comment">// float maxDist = params.dp /100.0f;</span>

    <span class="hljs-keyword">if</span> (dist &lt; interactDist)
    &#123;
        <span class="hljs-comment">// density</span>
        density = mass*<span class="hljs-built_in">poly6Kernel</span>(posA, posB, h);
    &#125;
    
    <span class="hljs-keyword">return</span> density;
&#125;</code></pre></div>
<p>step 4: update <code>force</code> by function <code>SPHForce</code>, passing the resultant force to <code>integrate_verlet</code></p>
<p>The final work flow in this stage is such that:</p>

<div class="markmap-container" style="height:300px">
  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;integrate_verlet(force)&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;&lt;span style=\&quot;color:#003366;\&quot;&gt;if step&amp;gt;0&lt;/span&gt;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;vel_2 = vel_1&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;vel_1 = vel&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;&lt;span style=\&quot;color:#003366;\&quot;&gt;if step==0 || step%50 == 0&lt;/span&gt;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;vel +=  force * deltaTime;&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;pos +=  vel * deltaTime + pow(deltaTime,2) * force * 0.5f;&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;&lt;span style=\&quot;color:#003366;\&quot;&gt;else&lt;/span&gt;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;vel = vel_2 +  force * deltaTime * 2;&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;pos +=  vel * deltaTime + pow(deltaTime,2) * force * 0.5f;&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;step++&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;Boundary condition&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;SPHDensityPressure(pos)&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;SPHDensityPressureD&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;density = 0;&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;pressure = 0;&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;density += SPHDensityCell;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[20,21]},&quot;v&quot;:&quot;(Neighboring search)&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[21,22]},&quot;v&quot;:&quot;SPHDensityParticles&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:12,&quot;p&quot;:{&quot;lines&quot;:[22,23]},&quot;v&quot;:&quot;(accumulate density)&quot;}]}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[23,24]},&quot;v&quot;:&quot;pressure = calculatePressure(density);&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[24,25]},&quot;v&quot;:&quot;SPHForce(pos, density, pressure)&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[25,26]},&quot;v&quot;:&quot;SPHForceD&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[26,27]},&quot;v&quot;:&quot;force = 0;&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[27,28]},&quot;v&quot;:&quot;force += SPHForceCell;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[28,29]},&quot;v&quot;:&quot;(Neighboring search)&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:10,&quot;p&quot;:{&quot;lines&quot;:[29,30]},&quot;v&quot;:&quot;SPHForceParticles&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:12,&quot;p&quot;:{&quot;lines&quot;:[30,31]},&quot;v&quot;:&quot;(accumulate pressure force)&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:12,&quot;p&quot;:{&quot;lines&quot;:[31,32]},&quot;v&quot;:&quot;(accumulate viscosity force)&quot;}]}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[32,33]},&quot;v&quot;:&quot;force += gravity;&quot;}]}]}],&quot;p&quot;:{}}"/>
</div>

<h4 id="result">result</h4>
<table>
<tbody>
<tr class="odd">
<td><img src="/2022/09/20/hand-written-SPH-method/SPH_comparison_o.gif" srcset="/img/loading.gif" lazyload alt="DEM method" style="zoom:80%;"></td>
<td><img src="/2022/09/20/hand-written-SPH-method/DEM_comparison_o.gif" srcset="/img/loading.gif" lazyload alt="SPH method" style="zoom:80%;"></td>
</tr>
<tr class="even">
<td><img src="/2022/09/20/hand-written-SPH-method/SPH result1 n=80000_o.gif" srcset="/img/loading.gif" lazyload alt="SPH result1 n=80000" style="zoom:80%;"></td>
<td><img src="/2022/09/20/hand-written-SPH-method/SPH result2 n=80000_o.gif" srcset="/img/loading.gif" lazyload alt="SPH result2 n=80000" style="zoom:80%;"></td>
</tr>
</tbody>
</table>
<h4 id="problem-that-still-exist">problem that still exist</h4>
<h5 id="boundary-problem">boundary problem</h5>
<p>To manifest better the problem, take a detail look at the <code>numParticles = 80000</code> example,</p>
<table>
<thead>
<tr class="header">
<th>angle 1</th>
<th>angle 2</th>
<th>angle 3</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><img src="/2022/09/20/hand-written-SPH-method/SPH method, boundary problem angle 1.png" srcset="/img/loading.gif" lazyload alt="SPH method, boundary problem angle 1" style="zoom:80%;"></td>
<td><img src="/2022/09/20/hand-written-SPH-method/SPH method, boundary problem angle 2.png" srcset="/img/loading.gif" lazyload alt="SPH method, boundary problem angle 2" style="zoom:80%;"></td>
<td><img src="/2022/09/20/hand-written-SPH-method/SPH method, boundary problem angle 3.png" srcset="/img/loading.gif" lazyload alt="SPH method, boundary problem angle 3" style="zoom:80%;"></td>
</tr>
</tbody>
</table>
<p>A bunch of dense particles lay on the boundary resulting a huge density/pressure region, pushing the particles away from it, leaving a unphysical gap. Need a modification to the boundary.</p>
<h3 id="stage-4-boundary">Stage 4: Boundary</h3>
<p>In former granular collision model<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="Green, S. (2008). CUDA Particles. Technical Report contained in the CUDA SDK, www.nvidia.com.">[2]</span></a></sup>, the boundary condition can be provided precisely as the radius of the particle is physical.</p>
<p><img src="/2022/09/20/hand-written-SPH-method/Original boundary condition.png" srcset="/img/loading.gif" lazyload alt="Original boundary condition" style="zoom:28%;"></p>
<p>To achieve the force of boundary to particles, following the work of Crespo at.al<sup id="fnref:18" class="footnote-ref"><a href="#fn:18" rel="footnote"><span class="hint--top hint--rounded" aria-label="Crespo AJC, GÃ³mez-Gesteira M and Dalrymple RA. 2007. Boundary conditions generated by  dynamic particles in SPH methods. Computers, Materials &amp; Continua, 5, 173-184">[18]</span></a></sup>, we arrange a layer of static particles regularly spanned on the boundary with same distance <code>coefDp*dp</code>. The density and pressure of the boundary particles is changed with the iteration, while the velocity and position of them remains the same.</p>
<h4 id="code-3">code</h4>
<h5 id="update-3">update</h5>
<p>Modify the arrangement of particles in <code>initGrid</code>. At first, arrange the bottom particles</p>
<div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (uint z = <span class="hljs-number">0</span>; z &lt; m_params.numNb + <span class="hljs-number">1</span>; z++)
&#123;
    <span class="hljs-keyword">for</span> (uint x = <span class="hljs-number">0</span>; x &lt; m_params.numNb + <span class="hljs-number">1</span>; x++)
    &#123;
        uint j = (z * (m_params.numNb + <span class="hljs-number">1</span>)) + x;
        m_hPos[j * <span class="hljs-number">4</span>] = (m_params.dp * m_params.coefDp * x) + m_params.worldOrigin.x;
        m_hPos[j * <span class="hljs-number">4</span> + <span class="hljs-number">1</span>] = m_params.worldOrigin.y;
        m_hPos[j * <span class="hljs-number">4</span> + <span class="hljs-number">2</span>] = (m_params.dp * m_params.coefDp * z) + m_params.worldOrigin.z;
        m_hPos[j * <span class="hljs-number">4</span> + <span class="hljs-number">3</span>] = <span class="hljs-number">-1.0f</span>;
    &#125;
&#125;</code></pre></div>
<p>Then the other boundary particles arrange like this.</p>
<p>To improve the efficiency on boundary top, we don't arrange particles there and the we arrange particles on surrounding faces with a certain height <code>coefBh * (woldMaxPos.y - worldOriginPos.y)</code> .</p>
<h4 id="result-1">result</h4>
<p>After validation, the particle system works better when the distance of boundary particles is <code>0.6dp</code>. Choose <code>coefBh</code> as <code>2/3</code>.</p>
<p><img src="/2022/09/20/hand-written-SPH-method/finish boundary_o.gif" srcset="/img/loading.gif" lazyload alt="finish boundary" style="zoom:80%;"></p>
<h3 id="stage-5-multiple-gpu">Stage 5: Multiple GPU</h3>
<h4 id="problems">Problems</h4>
<p>The CUDA environment does not support, natively, a cooperative multi-GPU model. The model is based more on a single-core, single-GPU relationship. This works really well for tasks that are independent of one another, but is rather a pain if you wish to write a task that needs to have the GPUs cooperate in some way.</p>
<p>Algorithm, compared with multi-GPU machine learning, Halo Exchange might be needed: <a target="_blank" rel="noopener" href="https://pdc-support.github.io/introduction-to-mpi/05-parallel-paradigms/index.html">Parallel Paradigms and Parallel Algorithms â€“ Introduction to Parallel Programming with MPI</a></p>
<ul>
<li>GPU peer-to-peer communication model provided as of the 4.0 SDK version or CPU-level primitives to cooperate at the CPU level</li>
<li>One-core or multi-core</li>
<li>MPI or ZeroMQ</li>
</ul>
<p>Calculate the theoretical speedup, and test for each roots.</p>
<h4 id="resources">Resources</h4>
<p>Book <a target="_blank" rel="noopener" href="https://github.com/dipeshdd/BOOKS/blob/master/CUDA%20Programming_2013%20by%20shane%20cook.pdf">CUDA Programming by Shane Cook</a></p>
<ul>
<li>Chapter 8 Multi-CPU and Multi-GPU Solutions</li>
</ul>
<p>Book <a target="_blank" rel="noopener" href="https://docs.nvidia.com/cuda/pdf/CUDA_C_Programming_Guide.pdf">CUDA C Programming Guide by NVIDIA</a></p>
<ul>
<li><strong>NOT Recommended</strong></li>
</ul>
<p>Course <a target="_blank" rel="noopener" href="https://www.nvidia.cn/training/instructor-led-workshops/cuda-multi-gpu/">CUDA Multi GPU Training by NVIDIA</a></p>
<ul>
<li><strong>NOT Free</strong></li>
</ul>
<p>Free course</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1if4y1i7yp">06.streams and mutiple GPU</a></p></li>
<li><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Vr4y1w78N">08.MPI-GPU cluster</a></p></li>
<li><p><strong>NOT Recommended</strong></p></li>
</ul>
<h2 id="references">References</h2>
<section class="footnotes">
<div class="footnote-list">
<ol>
<li>
<span id="fn:1" class="footnote-text"><span>HÃ©rault, A., Bilotta, G., &amp; Dalrymple, R. A. (2010). Sph on gpu with cuda. <em>Journal of Hydraulic Research</em>, <em>48</em>(sup1), 74-79. <a href="#fnref:1" rev="footnote" class="footnote-backref"> â†©ï¸Ž</a></span></span>
</li>
<li>
<span id="fn:2" class="footnote-text"><span>Green, S. (2008). CUDA Particles. Technical Report contained in the CUDA SDK, www.nvidia.com. <a href="#fnref:2" rev="footnote" class="footnote-backref"> â†©ï¸Ž</a></span></span>
</li>
<li>
<span id="fn:3" class="footnote-text"><span>Crespo, A. J., DomÃ­nguez, J. M., Rogers, B. D., GÃ³mez-Gesteira, M., Longshaw, S., Canelas, R. J. F. B., ... &amp; GarcÃ­a-Feal, O. (2015). DualSPHysics: Open-source parallel CFD solver based on Smoothed Particle Hydrodynamics (SPH). <em>Computer Physics Communications</em>, <em>187</em>, 204-216. <a href="#fnref:3" rev="footnote" class="footnote-backref"> â†©ï¸Ž</a></span></span>
</li>
<li>
<span id="fn:4" class="footnote-text"><span>Monaghan JJ. 1992. Smoothed particle hydrodynamics. Annual Review of Astronomy and Astrophysics, 30, 543- 574. <a href="#fnref:4" rev="footnote" class="footnote-backref"> â†©ï¸Ž</a></span></span>
</li>
<li>
<span id="fn:5" class="footnote-text"><span>Dalrymple RA and Rogers BD. 2006. Numerical modeling of water waves with the SPH method. Coastal Engineering, 53, 141â€“147. <a href="#fnref:5" rev="footnote" class="footnote-backref"> â†©ï¸Ž</a></span></span>
</li>
<li>
<span id="fn:6" class="footnote-text"><span>Verlet L. 1967. Computer experiments on classical fluids. I. Thermodynamical properties of Lennard-Jones molecules. Physical Review, 159, 98-103. <a href="#fnref:6" rev="footnote" class="footnote-backref"> â†©ï¸Ž</a></span></span>
</li>
<li>
<span id="fn:7" class="footnote-text"><span>Leimkuhler BJ, Reich S, Skeel RD. 1996. Integration Methods for Molecular dynamic IMA Volume in Mathematics and its application. Springer. <a href="#fnref:7" rev="footnote" class="footnote-backref"> â†©ï¸Ž</a></span></span>
</li>
<li>
<span id="fn:8" class="footnote-text"><span>Monaghan JJ and Kos A. 1999. Solitary waves on a Cretan beach. Journal of Waterway, Port, Coastal and Ocean Engineering, 125, 145-154. <a href="#fnref:8" rev="footnote" class="footnote-backref"> â†©ï¸Ž</a></span></span>
</li>
<li>
<span id="fn:9" class="footnote-text"><span>Monaghan JJ and Lattanzio JC. 1985. A refined method for astrophysical problems. Astron. Astrophys, 149, 135â€“143. <a href="#fnref:9" rev="footnote" class="footnote-backref"> â†©ï¸Ž</a></span></span>
</li>
<li>
<span id="fn:10" class="footnote-text"><span>Molteni, D and Colagrossi A. 2009. A simple procedure to improve the pressure evaluation in hydrodynamic context using the SPH, Computer Physics Communications, 180 (6), 861â€“872 <a href="#fnref:10" rev="footnote" class="footnote-backref"> â†©ï¸Ž</a></span></span>
</li>
<li>
<span id="fn:11" class="footnote-text"><span>Wendland H. 1995. Piecewiese polynomial, positive definite and compactly supported radial functions of minimal degree. Advances in Computational Mathematics 4, 389-396. <a href="#fnref:11" rev="footnote" class="footnote-backref"> â†©ï¸Ž</a></span></span>
</li>
<li>
<span id="fn:12" class="footnote-text"><span>Monaghan JJ. 1994. Simulating free surface flows with SPH. Journal of Computational Physics, 110, 399â€“406. <a href="#fnref:12" rev="footnote" class="footnote-backref"> â†©ï¸Ž</a></span></span>
</li>
<li>
<span id="fn:13" class="footnote-text"><span>Crespo, A. J. C., Dominguez, J. M., GÃ³mez-Gesteira, M., Barreiro, A., &amp; Rogers, B. (2011). User guide for DualSPHysics code. <em>University of Vigo: Vigo, Spain</em>. <a href="#fnref:13" rev="footnote" class="footnote-backref"> â†©ï¸Ž</a></span></span>
</li>
<li>
<span id="fn:14" class="footnote-text"><span>Qin, Y., Wu, J., Hu, Q., Ghista, D. N., &amp; Wong, K. K. (2017). Computational evaluation of smoothed particle hydrodynamics for implementing blood flow modelling through CT reconstructed arteries. <em>Journal of X-ray science and technology</em>, <em>25</em>(2), 213â€“232. https://doi.org/10.3233/XST-17255 <a href="#fnref:14" rev="footnote" class="footnote-backref"> â†©ï¸Ž</a></span></span>
</li>
<li>
<span id="fn:15" class="footnote-text"><span>MÃ¼ller, M., Charypar, D., &amp; Gross, M. (2003, July). Particle-based fluid simulation for interactive applications. In <em>Proceedings of the 2003 ACM SIGGRAPH/Eurographics symposium on Computer animation</em> (pp. 154-159) <a href="#fnref:15" rev="footnote" class="footnote-backref"> â†©ï¸Ž</a></span></span>
</li>
<li>
<span id="fn:16" class="footnote-text"><span>Desbrun, M., Gascuel, MP. (1996). Smoothed Particles: A new paradigm for animating highly deformable bodies. In: Boulic, R., HÃ©gron, G. (eds) Computer Animation and Simulation â€™96. Eurographics. Springer, Vienna. https://doi.org/10.1007/978-3-7091-7486-9_5 <a href="#fnref:16" rev="footnote" class="footnote-backref"> â†©ï¸Ž</a></span></span>
</li>
<li>
<span id="fn:17" class="footnote-text"><span>Koschier D, Bender J, Solenthaler B, et al. Smoothed Particle Hydrodynamics Techniques for the Physics Based Simulation of Fluids and Solids[J]. 2019. <a href="#fnref:17" rev="footnote" class="footnote-backref"> â†©ï¸Ž</a></span></span>
</li>
<li>
<span id="fn:18" class="footnote-text"><span>Crespo AJC, GÃ³mez-Gesteira M and Dalrymple RA. 2007. Boundary conditions generated by dynamic particles in SPH methods. Computers, Materials &amp; Continua, 5, 173-184 <a href="#fnref:18" rev="footnote" class="footnote-backref"> â†©ï¸Ž</a></span></span>
</li>
<li>
<span id="fn:19" class="footnote-text"><span>DomÃ­nguez, J. M., Crespo, A. J. C., GÃ³mezâ€Gesteira, M., &amp; Marongiu, J. (2011). Neighbour lists in smoothed particle hydrodynamics. <em>International Journal for Numerical Methods in Fluids</em>, <em>67</em>(12), 2026-2042. <a href="#fnref:19" rev="footnote" class="footnote-backref"> â†©ï¸Ž</a></span></span>
</li>
<li>
<span id="fn:20" class="footnote-text"><span>Libersky, L. D., Petschek, A. G., Carney, T. C., Hipp, J. R., &amp; Allahdadi, F. A. (1993). High strain Lagrangian hydrodynamics: a three-dimensional SPH code for dynamic material response. <em>Journal of computational physics</em>, <em>109</em>(1), 67-75. <a href="#fnref:20" rev="footnote" class="footnote-backref"> â†©ï¸Ž</a></span></span>
</li>
<li>
<span id="fn:21" class="footnote-text"><span>Koschier, D., Bender, J., Solenthaler, B., &amp; Teschner, M. (2020). Smoothed particle hydrodynamics techniques for the physics based simulation of fluids and solids. <em>arXiv preprint arXiv:2009.06944</em>. <a href="#fnref:21" rev="footnote" class="footnote-backref"> â†©ï¸Ž</a></span></span>
</li>
<li>
<span id="fn:22" class="footnote-text"><span>Lo EYM and Shao S. 2002. Simulation of near-shore solitary wave mechanics by an incompressible SPH method. Applied Ocean Research, 24, 275-286. <a href="#fnref:22" rev="footnote" class="footnote-backref"> â†©ï¸Ž</a></span></span>
</li>
<li>
<span id="fn:23" class="footnote-text"><span>Gotoh H, Shao S, Memita T. 2001. SPH-LES model for numerical investigation of wave interaction with partially immersed breakwater. Coastal Engineering Journal, 46(1), 39â€“63. <a href="#fnref:23" rev="footnote" class="footnote-backref"> â†©ï¸Ž</a></span></span>
</li>
</ol>
</div>
</section>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/fluid-dynamics/">#fluid dynamics</a>
      
        <a href="/tags/CUDA/">#CUDA</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>hand written SPH method</div>
      <div>https://daydreamatnight.github.io/2022/09/20/hand-written-SPH-method/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>Ryan LI, Wen Wang</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>September 20, 2022</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
                <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="NC - Non-commercial">
                    <i class="iconfont icon-nc"></i>
                  </span>
                </a>
              
                <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="SA - Share-alike">
                    <i class="iconfont icon-sa"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/09/29/RANS-recap/" title="RANS recap">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">RANS recap</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/09/15/CUDA-example-particles/" title="CUDA example particles">
                        <span class="hidden-mobile">CUDA example particles</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;Table of Contents</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  





  <script>
  Fluid.utils.createScript('https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js', function() {
    mermaid.initialize({"theme":"default"});

    Fluid.events.registerRefreshCallback(function() {
      if ('mermaid' in window) {
        mermaid.init();
      }
    });
  });
</script>






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://lsongrui.github.io/" target="_blank" rel="nofollow noopener"><span>Shoushou</span></a> <i class="iconfont icon-love"></i> <a href="https://jingyicc.github.io/" target="_blank" rel="nofollow noopener"><span>Rourou</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        Toal views: 
        <span id="busuanzi_value_site_pv"></span>
         
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        Total visiters: 
        <span id="busuanzi_value_site_uv"></span>
        
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    
      <script  src="/js/img-lazyload.js" ></script>
    
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  
<script src="//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/DynamicLine.min.js"></script>
<script src="//cdn.jsdelivr.net/npm/echarts@4.8.0/dist/echarts.min.js".js"></script>
<script src="/%3Cscript%20src=%22https:/cdn.jsdelivr.net/npm/echarts-gl@1.1.1/dist/echarts-gl.min.js"></script>



<!-- ä¸»é¢˜çš„å¯åŠ¨é¡¹ï¼Œå°†å®ƒä¿æŒåœ¨æœ€åº•éƒ¨ -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>

<script src="https://fastly.jsdelivr.net/npm/d3@6"></script>
<script src="https://fastly.jsdelivr.net/npm/markmap-view@0.2.7"></script>


<style>
.markmap-container{
  display:flex;
  justify-content:center;
  margin:0 auto;
  width:90%;
  height:500px
}
.markmap-container svg{
  width:100%;height:100%
}
@media(max-width:768px){
  .markmap-container{
    height:400px
  }
}</style>
<script>
function initMarkMap(){
  document.querySelectorAll('.markmap-container>svg').forEach(el =>{
    markmap.Markmap.create(el, null, JSON.parse(el.getAttribute('data')))
  })
};
initMarkMap();

</script></body>
</html>
